from ctypes import *
from ctypes.wintypes import *
from dataclasses import dataclass
from termcolor import colored
import sys
import os

Kernel32 = windll.kernel32
Ntdll = windll.ntdll

# This is used for debugging at some point I should implement
# argparse to give the option to enable verbose mode at runtime
VERBOSE_MODE = True

def DirectObjectMatching(Factors):
    """
    @brief      Returns a list of suitable direct objects to use for
                pool spraying based on the specified ChunkSize.

                For example, if our ChunkSize is 0x200 then the
                function will return all instances of objects
                which are direct factors of the ChunkSize.
    @calls      None
    @callers    main()
    
    @param      A list of numbers that are factors of ChunkSize
    @retns      None
    """

    print(colored("[*] Searching for direct object matches!", "yellow"))

    # @TODO: Construct an actual dictionary of events, not test data
    TestDict = {
        "object": "Event",
        "size": 0x80
    }

    TestDict2 = {
        "object": "File",
        "size": 0x190
    }

    DictList = []
    DictList.append(TestDict)
    DictList.append(TestDict2)

    MatchedObjs = []

    # Return all factors in hex
    for i in Factors:
        pObjSize = int(i)
        if VERBOSE_MODE == True:
            print(colored(f"\t[*] Checking Factor Size: {hex(pObjSize)}", "yellow"))

        # Check if any factors match kernel objects
        for d in DictList:
            if VERBOSE_MODE == True:
                print(colored(f"\t[*] Checking Object Size: {hex(d['size'])}", "yellow"))
            if d['size'] == pObjSize:
                print(colored(f"\t[!] Object Size: {hex(pObjSize)} matches Kernel Object: {d['object']}", 'green'))
                MatchedObj = d['object']
                MatchedObjs.append(MatchedObj)

    # @TODO: Should return the number of objects to free
    #        after allocating to fill the specified chunk size.
    #        For example if the chunk size is 0x200 and we use
    #        objects of 0x80 then we need to free those objects
    #        4 times to fill the chunk size of 0x200

    if not MatchedObjs:
        print(colored("\t[-] No direct matches found!\n", "red"))
    else:
        print(colored(f"\t[+] Matches found: {MatchedObjs}\n", "green"))


def AdvancedObjectMatching(ChunkSize):
    """
    @brief      Perform "Advanced" matching of Kernel Objects.
                For example, find chains of objects which are
                equal to the chunk size. 

                Example:
                    File Object = 0x190
                    Event Object = 0x80

                    0x190 + 0x80 = 0x210
    
    @note       This function only has a maximum recursion of 2
                i.e, it will only look for chains of two objects
    """

    print(colored("[*] Searching for advanced object matches!", "yellow"))

    # @TODO: Construct an actual dictionary of events, not test data
    TestDict = {
        "object": "Event",
        "size": 0x80
    }
    TestDict2 = {
        "object": "File",
        "size": 0x190
    }

    DictList = []
    DictList.append(TestDict)
    DictList.append(TestDict2)

    MatchedObjs = []

    for d in DictList:
        ObjSize = d['size']
        ObjName = d['object']

        if VERBOSE_MODE == True:
            print(colored(f"\t[*] Checking Object: {ObjName} Size: {hex(ObjSize)}", "yellow"))

        # Mod ChunkSize & ObjSize
        Remainder = int(ChunkSize % ObjSize)
        if VERBOSE_MODE == True:
            print(colored(f"\t[+] Remainder: {hex(Remainder)}", "green"))

        # Check if remainder less than 0x30
        if Remainder < 48 and Remainder > 0: # If an object has a remainder of 0 then it can be used since the chunk will be filled.
            if VERBOSE_MODE == True:
                print(colored(f"\t[-] Can't use {ObjName}\n", "red"))
            continue
        
        # Check if remainder = any object sizes
        for dd in DictList:
            if dd['size'] == Remainder:
                ChainObjSize = dd['size']
                ChainObjName = dd['object']
                if VERBOSE_MODE == True:
                    print(colored(f"\t[!] Can use object: {ObjName} with object: {dd['object']} ", "green"))
                
                # Sanity check that chained objects = ChunkSize
                if VERBOSE_MODE == True:
                    print(colored("\t[*] Performing sanity check!\n", "yellow"))
                CheckSize = ObjSize + ChainObjSize
                if CheckSize != ChunkSize:
                    print(colored(f"\t[-] False match!", "red"))
                elif CheckSize == ChunkSize:
                    if VERBOSE_MODE == True:
                        print(colored(f"\t[!] Positive match!", "green"))
                    MatchedObj = ObjName + " + " + ChainObjName
                    MatchedObjs.append(MatchedObj)
                else:
                    print(colored("\t[-] Something went wrong!\n", "red"))

    if not MatchedObjs:
        print(colored("\t[-] No matches found!", "red"))
    else:
        print(colored(f"\t[+] Matches found: {MatchedObjs}\n", "green"))

def FindKernelObjectSizes(ObjHandles):
    """
    @brief      Obtain an array of all kernel object sizes
    @calls      None
    @callers    FindKernelObjects()

    @param      An array of kernel object handles
    @retns      A dictionary of kernel object sizes
    """

    for handle in ObjHandles:
        print(f"{handle}")

def FindKernelObjects():
    """
    @brief      Obtain a handle to all avaialable kernel objects
    @calls      FindKernelObjectSizes()
    @callers    main()

    @param      None
    @retns      An array of kernel object handles
    """

    """
    @note       Objects marked with * are implemented.

    Access Token            - CreateRestrictedToken()
    Change Notification     - FindFirstChangeNotification()
    *File                   - CreateFile()
    Desktop                 - GetThreadDesktop()
    *Event                  - CreateEvent()
    EventLog                - OpenEventLog()
    File Mapping            - CreateFileMapping()
    Find File               - FindFirstFile()
    Heap                    - HeapCreate()
    I/O Completion Port     - CreateIoCompletionPort()
    Job                     - CreateJobObject()
    Mailslot                - CreateMailslot()
    Memory Resource Notify  - CreateMemoryResourceNotification()
    Module                  - LoadLibrary()
    Mutex                   - CreateMutex()
    Pipe                    - CreatePipe()
    Process                 - CreateProcess()
    Semaphore               - CreateSemaphore()
    Socket                  - Socket()
    *Thread                 - CreateThread()
    Timer                   - CreateWaitableTimer()
    Update Resource         - BeginUpdateResource()
    """

    ObjHandles = []

    print(colored("[*] Finding Kernel Objects!\n", "yellow"))

    # @TODO: Figure out a way of creating all these
    #        kernel objects without calling them and
    #        appending them one-by-one as this seems
    #        awfully inefficient.

    TmpObjHandle = Kernel32.CreateEventA(0, 0, 0, 0)
    ObjHandles.append(TmpObjHandle)

    TmpObjHandle = Kernel32.CreateFileA("C:\\", )
    ObjHandles.append(TmpObjHandle)


    TmpObjHandle = Kernel32.CreateThread()
    ObjHandles.append(TmpObjHandle)


    ''' 
    @note:  I am not currently sure of the best way to get the size of the kernel
            objects using ctypes. In WinDbg we can simply use the !pool command
            however we clearly don't have that command here. The current thinking
            is that we can use the NtQuerySystemInformation and specify the
            SYSTEM_INFORMATION_CLASS parameter as SystemProcessInformation. Based
            on the documentation:

            - https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation

            This SYSTEM_INFORMATION_CLASS can return data in respect to the NonPaged
            Pool. As of right now I am not entirely sure what that data contains.
    
    @note:  An additional potential source of this information is a call to
            GetProcessMemoryInfo from pspi.h:

            - https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getprocessmemoryinfo
    '''      

    print(ObjHandles)
    #FindKernelObjectSizes(ObjHandles)


def FactorChunk(ChunkSize):
    '''
    @brief      Find factors of the chunk size so that we can calculate which
                kernel objects are suitable for pool spraying.
    @calls      None
    @callers    CheckChunkSize()

    @param      An integer to find factors of
    @retn       An array of factors of the chunk size
    '''
    return [n for n in range(1, ChunkSize + 1) if ChunkSize % n == 0]

def ReduceFactors(Factors):
    '''
    @brief      Reduce array of factors to a sensible list based on
                available kernel object sizes, i.e, we can't allocate
                a kernel object of size 15 for example. Because no such 
                object exists...
    @calls      None
    @callers    CheckChunkSize()
    
    @param      An array of factors
    @retn       An array of "sensible" factors
    '''
    return [n for n in Factors if n > 40]

def CheckChunkSize(ChunkSize):
    """
    @brief      Checks the size of a specified chunk
    @calls      FactorChunk(), ReduceFactors()
    @callers    main()

    @param      A size of a pool chunk
    @retns      A "checked" ChunkSize
    @retns      An array of factors of ChunkSize
    """

    print(colored("[*] Checking chunk size!\n", "yellow"))

    # Check if the chunk is greater than 0x30
    # @NOTE This number might need some adjusting.
    if ChunkSize < 48:
        print(colored("\t[!] FATAL: Your chunk size must be greater than 0x30!\n", "red"))
        sys.exit(-1)

    # @TODO There's probably some other checks
    #       that we should do here on the ChunkSize

    # Get an array of factors of ChunkSize
    Factors = FactorChunk(ChunkSize)
    if VERBOSE_MODE == True:
        print(f"[+] Factors: {Factors}")

    # Get an array of sensible factors of ChunkSize
    Factors = ReduceFactors(Factors)
    if VERBOSE_MODE == True:
        print(f"[+] Factors: {Factors}")

    # We return the ChunkSize so that the "checked"
    # chunk size is returned, not the original one.
    return ChunkSize, Factors

def main():
    print(colored("""
██████╗  ██████╗  ██████╗ ██╗          ██████╗ ██████╗      ██╗███████╗ ██████╗████████╗    ███████╗██╗███╗   ██╗██████╗ ███████╗██████╗ 
██╔══██╗██╔═══██╗██╔═══██╗██║         ██╔═══██╗██╔══██╗     ██║██╔════╝██╔════╝╚══██╔══╝    ██╔════╝██║████╗  ██║██╔══██╗██╔════╝██╔══██╗
██████╔╝██║   ██║██║   ██║██║         ██║   ██║██████╔╝     ██║█████╗  ██║        ██║       █████╗  ██║██╔██╗ ██║██║  ██║█████╗  ██████╔╝
██╔═══╝ ██║   ██║██║   ██║██║         ██║   ██║██╔══██╗██   ██║██╔══╝  ██║        ██║       ██╔══╝  ██║██║╚██╗██║██║  ██║██╔══╝  ██╔══██╗
██║     ╚██████╔╝╚██████╔╝███████╗    ╚██████╔╝██████╔╝╚█████╔╝███████╗╚██████╗   ██║       ██║     ██║██║ ╚████║██████╔╝███████╗██║  ██║
╚═╝      ╚═════╝  ╚═════╝ ╚══════╝     ╚═════╝ ╚═════╝  ╚════╝ ╚══════╝ ╚═════╝   ╚═╝       ╚═╝     ╚═╝╚═╝  ╚═══╝╚═════╝ ╚══════╝╚═╝  ╚═╝
-----------------------------------------------------------------------------------------------------------------------------------------""", "blue"))

    print(colored("Made by Linxz", "blue"))

    if len(sys.argv) < 2:
        print(colored("\n[!] FATAL: Please enter a chunk size in hex!", "red"))
        print(colored("""[+] Help: 
        Chunk Size: 0x210""", "yellow"))

        sys.exit(-1)
    else:
        ChunkSize = sys.argv[1]
        ChunkSize = int(ChunkSize, base=16) # Take ChunkSize as hex.
        print(colored(f"\n\n[+] Your chunk size: {hex(ChunkSize)}\n", "green"))
        ChunkSize, Factors = CheckChunkSize(ChunkSize)


    # Get an array of Kernel Object handles
    FindKernelObjects()

    #DirectObjectMatching(Factors)
    #AdvancedObjectMatching(ChunkSize)

if __name__ == '__main__':
    os.system('color')
    main()